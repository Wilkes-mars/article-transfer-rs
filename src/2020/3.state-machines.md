>* STATE MACHINES 译文
>* 原文链接：https://blog.yoshuawuyts.com/state-machines/
>* 原文作者：[https://blog.yoshuawuyts.com/](https://blog.yoshuawuyts.com/)
>* 译文来自：https://github.com/suhanyujie/article-transfer-rs/
>* 译者：[suhanyujie](https://github.com/suhanyujie)
>* 译者博客：[suhanyujie](https://ishenghuo.cnblogs.com/)
>* ps：水平有限，翻译不当之处，还请指正。
>* 标签：数据库，Rust，解析

Every now and then I like to think about topics that don't directly relate to my daily work. One of those topics has been parsers: back in January I wrote about [byte-ordered stream parsing](https://blog.yoshuawuyts.com/byte-ordered-stream-parsing/) and how I think we can improve streaming parsing in Rust with a small set of API additions.
>很多时候，我想到一些和日常工作无关的话题。其中一个主题就是解析器：在 1 月份，我写了一篇关于[字节顺序流解析](https://blog.yoshuawuyts.com/byte-ordered-stream-parsing/)的文章，并且我认为我们可以通过添加一组 API 来改进 Rust 中的流解析。

I've recently been thinking of how to improve beyond that, and one topic of interest has been state machines. [\[1\]](https://blog.yoshuawuyts.com/state-machines/#parsers) Much of parsing logic includes sequences of: "If you see character X, read until character Y, then look for character Z." This sequence can best be described as a "transition between states", and state machines are a common technique/structure/pattern to describe these. [\[2\]](https://blog.yoshuawuyts.com/state-machines/#quick)
>最近，我一直在思考改善方案，其中一个有趣的方式是状态机。[\[1\]](https://blog.yoshuawuyts.com/state-machines/#parsers) 很多解析逻辑包括这样的序列：如果你有了字符 X，则读取字符直到 Y，然后寻找字符 Z。这段描述可以称为“状态之间的转换”，而状态机则是描述这些状态转换的常用技术/结构/模式[\[2\]](https://blog.yoshuawuyts.com/state-machines/#quick)

## 状态机是什么？
在 Rust 中的状态通常以 enum 类型体现：一个 boolean 可以是 `true` 或 `false`。一个 `Option` 可以是 `Some` 或 `None`。状态机是描述状态之间的关系。比如，交通灯可以从红变绿，但不能从红到黄 —— 它必须先变绿，才能变黄。[\[3\]](https://blog.yoshuawuyts.com/state-machines/#yellow).

![](https://blog.yoshuawuyts.com/assets/graphs/cyclic_graph.jpg)

_上图描述了 4 种状态和 5 种转换_，由 [@_lrlna](https://twitter.com/_lrlna) 为我们的 ["Graphs"](https://blog.yoshuawuyts.com/graphs/) 文章所作。 

状态机不仅仅是编码哪些状态转换是有效的。如，在金融系统中，在确定事务成功之前可能需要执行一些重要的检查。状态机允许我们对“成功”状态进行编码，也就是在“验证”状态之前必须有一个“校验”状态。

An interesting property that I personally value a lot in state machines is how much utility they provide in active codebases. Instead of encoding relations in boolean logic, they can be extracted into their own site. And in doing so they become more resilient against emergent bugs.
>在状态机中，有一个我觉得非常有趣且重要的属性是它们在活动代码库中提供了多少使用的东西。与用布尔逻辑编码关系不同的是，前者可以被提取（转换）到自己的状态现场。这样一来，它们对突发异常情况的抵抗力就会增强。

## 如今 Rust 中的状态机
既然我们已经初步了解了状态机是什么，并且希望用户能够相信它们的有用性，接下来我们看看，在 Rust 中实现它。我们这里所说的很多东西都是收到了 [Hoverbear 的“状态机模式”文章](https://hoverbear.org/blog/rust-state-machine-pattern)的启发，我推荐大家阅读它。

状态机的理想场景是在编译时对其进行完全编码：这样，如果我们的程序进行编译，我们可以确保发生的状态转换是我们定义的允许的状态转换。

如今的 Rust 中要实现这个是通过类型参数来做到的。如果以我们前面的“交通灯”为例，我们用 Rust 可以进行如下编码：

```rust
#[derive(Debug)]
pub struct Green;
#[derive(Debug)]
pub struct Yellow;
#[derive(Debug)]
pub struct Red;

#[derive(Debug)]
struct State<S> {
    _inner: S
}

impl State<Green> {
    pub fn new() -> State<Green> {
        State { _inner: Green{} }
    }
}

impl State<Green> {
    pub fn next(self) -> State<Yellow> {
        State { _inner: Yellow {} }
    }
}


impl State<Yellow> {
    pub fn next(self) -> State<Red> {
        State { _inner: Red {} }
    }
}

impl State<Red> {
    pub fn next(self) -> State<Green> {
        State { _inner: Green {} }
    }
}

fn main() {
    let state = State::new(); // green
    let state = state.next(); // yellow
    let state = state.next(); // red
    let state = state.next(); // green
    dbg!(state);
}
```

[Rust 训练场链接](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=9ac3f0d23b98a28dd94e12fb0f1a30ab)

正如你看到的，调用 `next` 可以将状态从一个值抓换为另一个。尽管方法可能看起来相同并且存在于多个结构体中：但它们是非常不同的。

如果我们在一个不正确的状态中尝试调用一个方法，编译器会提供一些有用的相关信息来改进。比如说，我们想确保自行车在绿灯亮的时候可以穿行。下面的例子是使自行车在红灯状态时穿行，此时就是一个典型的编译错误场景。

```rust
fn main() {
    let state = State::new(); // 绿灯
    let state = state.next(); // 黄灯
    let state = state.next(); // 红灯
    allow_bikes(&state);
    let state = state.next(); // 绿灯
}

fn allow_bikes(state: &State<Green>) {
    todo!();
}
```

```
Compiling playground v0.0.1 (/playground)
error[E0308]: mismatched types
  --> src/main.rs:42:17
   |
42 |     allow_bikes(&state);
   |                 ^^^^^^ expected struct `Green`, found struct `Red`
   |
   = note: expected reference `&State<Green>`
              found reference `&State<Red>`

error: aborting due to previous error
```

然而，这种模式有个比较大的限制就是不能在另一个结构体中存储状态；它只能以特定的方式存在于当前的栈中。所以，我们不能进行如下的操作：

```rust
struct Foo<S> {
    state: State<S>,
}
```

The moment we initialize `Foo` to take e.g. `Green` as its parameter, it can now no longer switch to `Red` in safe Rust. This is what enums are for, and unfortunately we can't use those here.
>当我们初始化 `Foo` 的时候。`Green` 是入参，在安全的 Rust 中，它现在不能再转换成 `Red`。这就是枚举的作用，不幸的是，我们暂且不用枚举。

现在，检查状态机系统的 crate 比较有前景的有 [machine](https://docs.rs/machine/0.3.0/machine/) 和 [state_machine_future](https://docs.rs/state_machine_future/0.2.0/state_machine_future/)。

## FUTURE 指引
>[P 编程语言](https://github.com/p-org/P/wiki/PingPong-program)将状态机作为一级类构造。它使用 `state` 关键字定义状态，并且使用 `on`、`goto` 和 `raise` 关键字在状态间切换[\[4\]](https://blog.yoshuawuyts.com/state-machines/#plaid)。看到这一点后，我开始思考：“Rust 是否有可能只进行最小的更爱就将一流的状态机作为语言的一部分吗？”嗯，我想，也许可以吧？

_在我们继续之前，我要声明：我不是语言设计师，也不是任何语言团队的成员。上面那些都是猜测。这一切都来自一个有趣的点子，而我在这方面也不是权威_。

因此，他们的想法是：“如果枚举是描述状态的一种方式，而方法是描述行为的一种方式，是否能将两者结合起来成为一个状态机？”

Currently enums have the limitation that its members aren't fully qualified types. But [imagine for a second we they were](https://github.com/rust-lang/rfcs/pull/2593). What that would mean is that we could reason about enum members as if they were full types.
>当前枚举类型的成员具有不完全合格的限制。但是[再仔细想一想它们](https://github.com/rust-lang/rfcs/pull/2593)。这意味着我们可以将枚举成员当做完整类型来推断。

Now imagine we could use enum members as arbitrary self types, and return enum members from functions [\[5\]](https://blog.yoshuawuyts.com/state-machines/#specialization). We could then rewrite our traffic example like this:
>现在假设我们可以使用枚举成员作为任意的 self 类型，并且从方法 [\[5\]](https://blog.yoshuawuyts.com/state-machines/#specialization) 中返回枚举成员。然后我们可以像这样重写交通灯示例：

```rust
enum State {
    Green,
    Yellow,
    Red,
}

impl State {
    pub fn new() -> Self::Green {
        Self::Green
    }

    pub fn next(self: Self::Green) -> Self::Yellow {
        Self::Yellow
    }

    pub fn next(self: Self::Yellow) -> Self::Red {
        Self::Red
    }

    pub fn next(self: Self::Red) -> Self::Green {
        Self::Green
    }
}

fn main() {
    let mut state = State::new(); // green
    state = state.next(); // yellow
    state = state.next(); // red
    state = state.next(); // green
}
```

As you can see this nicely tucks state back into a single enum, and uses named transitions to switch between one state to the other. This makes enums the single source of both states and transitions between states.
>正如你看到的，它很好地将状态重新压缩为单个枚举上，并使用命名的转换在一种和另一种状态之间切换。这使得枚举成为状态和状态切换的唯一来源。

此外，方法不仅可以返回 `Self`：它们还可以返回 result 或者 future；允许发生各种类型的转换。下面的诊断分析很有参考意义：

```
Compiling playground v0.0.1 (/playground)
error[E0308]: mismatched types
  --> src/main.rs:42:17
   |
42 |     allow_bikes(&state);
   |                 ^^^^^^ expected `State::Green`, found `State::Red`
   |
   = note: expected reference `&State::Green`
              found reference `&State::Red`

error: aborting due to previous error
```

然而，这里有很多猜测 "if" 绑定。是否有可能以这种方式充分地推理枚举成员？这是否有效？能实现这一点会有很副作用，这些需要更专业的人来解答。

## 结论
In this rather hastily written post we've shared what state machines are, how they can be authored in Rust today, their limitations, and speculated on language extensions to make them easier to author.

In principle it's already possible to write state machines in Rust today. The compiler will verify them for you, and provide helpful messages when things go wrong. It's somewhat of a testatement to how useful linear types are. However they come with severe limitations, and don't always feel the most natural to write.

What I like about the future direction I've sketched in this post is that it looks like a fairly natural extension to today's Rust. But would enable compiler-checked general-purpose state machines to exist in Rust, which is something that [doesn't seem common in programming languages](https://twitter.com/hillelogram/status/1243608940484734976).

What I like about the direction we've outlined in this post so far is that it sketches something that feels like a fairly natural extension to what Rust is like today.

Maybe this post will prove to be inspirational for first-class state machines in Rust at some point in the future. Or possibly I'm saying things that are strictly impossible. Either way, this has been a fun thought exercise, and figured it might be fun to share [\[6\]](https://blog.yoshuawuyts.com/state-machines/#share). Thanks for reading[\[7\]](https://blog.yoshuawuyts.com/state-machines/#times)!

## NOTES
1. Back in December I was exploring parsers, and got a feel for the difference between "parser combinators" and "parser generators". [Mountain Ghosts (James Coglan)](https://twitter.com/mountain_ghosts/status/1204061356661624832) pointed out on Twitter that there's another variant of parsers: Prolog's ["Definite clause grammars"](https://en.wikipedia.org/wiki/Definite_clause_grammar). After reading the Wiki entry on it it felt like it definitely looked like state machines. And I happen to know that the compiler [uses Prolog for type resolution](https://github.com/rust-lang/chalk). So I got to wonder: if Rust has state machines as part of the language, would that get us closer to being able to express parsers in a manner not too dissimilar from definite clause grammars? I bet someone with more knowledge about these things could say more on this. [←](https://blog.yoshuawuyts.com/state-machines/#footnote-reference-0)

2. It's 23:05 on a Monday here. I've been thinking about state machines all weekend for no good reason. So I'm writing this post in a single take to get it out of my mind and into a structured form before I lose my mind. [←](https://blog.yoshuawuyts.com/state-machines/#footnote-reference-1)

3. In Germany traffic lights go `green -> yellow -> red -> yellow -> green`, but let's pretend they're only `green -> yellow -> red -> green`. [←](https://blog.yoshuawuyts.com/state-machines/#footnote-reference-2)

4. I also found the [Plaid language](http://plaid-lang.org/) which talks about state machines a bunch, but most of it is written as PDFs, and source tarballs, so I didn't really research it further. [←](https://blog.yoshuawuyts.com/state-machines/#footnote-reference-3)

5. This probably needs specialization too. Insert hand waving / jazz hands here. [←](https://blog.yoshuawuyts.com/state-machines/#footnote-reference-4)

6. As I've been trying and not lose my mind; I've been thinking about state machines for 72 hours and needed to get this out of my system. [←](https://blog.yoshuawuyts.com/state-machines/#footnote-reference-5)

7. In these trying times. [←](https://blog.yoshuawuyts.com/state-machines/#footnote-reference-6)

## REFERENCES
View all references

https://blog.yoshuawuyts.com/byte-ordered-stream-parsing/
https://blog.yoshuawuyts.com/state-machines/#parsers
https://blog.yoshuawuyts.com/state-machines/#quick
https://twitter.com/mountain_ghosts/status/1204061356661624832
https://en.wikipedia.org/wiki/Definite_clause_grammar
https://github.com/rust-lang/chalk
https://blog.yoshuawuyts.com/state-machines/#yellow
https://twitter.com/_lrlna
https://blog.yoshuawuyts.com/graphs/
https://hoverbear.org/blog/rust-state-machine-pattern
https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=9ac3f0d23b98a28dd94e12fb0f1a30ab
https://docs.rs/machine/0.3.0/machine/
https://docs.rs/state_machine_future/0.2.0/state_machine_future/
https://github.com/p-org/P/wiki/PingPong-program
https://blog.yoshuawuyts.com/state-machines/#plaid
http://plaid-lang.org/
https://github.com/rust-lang/rfcs/pull/2593
https://blog.yoshuawuyts.com/state-machines/#specialization
https://twitter.com/hillelogram/status/1243608940484734976
https://blog.yoshuawuyts.com/state-machines/#share
https://blog.yoshuawuyts.com/state-machines/#times

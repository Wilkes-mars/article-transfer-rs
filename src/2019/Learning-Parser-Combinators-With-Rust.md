# 使用Rust进行解析器学习
* 这是一篇翻译文：*原文链接 https://bodil.lol/parser-combinators/*
* 翻译首发地址：https://github.com/suhanyujie/article-transfer-rs/blob/master/src/2019/Learning-Parser-Combinators-With-Rust.md
>正文开始：


* 本文面向会使用Rust编程的人员，提供一些解析器的基础知识。如果没有其他基础，将会解释和Rust无关的一些内容，并且，使用Rust实现这个会更加超出预期。如果你还不了解Rust，这个文章也不会讲如何使用Rust；如果你已经了解Rust，那它也不能打包票能教会您解析器知识。如果你想学习Rust，我推荐阅读[《The Rust Programming Language》](https://doc.rust-lang.org/book/)。

## 初学者的独白
* 在很多程序员的职业生涯中，可能都会有这样一个时刻，发现自己需要一个解析器。
* 小白程序员可能会问：解析器是什么？
* 中级程序员会问：这很简单，我会写正则表达式。
* 高级程序员会说：闪开，我知道 `lex` 和 `yacc` 。
* 只有小白的态度是端正的。
* 并不说正则不好。（但请不要尝试将一个复杂的解析器写成正则表达式。）也不是说使用像 `lexer` 生成器这种强大的工具就没有显得技术含量，这些工具经过长久的迭代和改进，已经达到了很好的程度。但从0开始学解析器是很有趣的。而如果你直接走正则表达式或解析器生成器的方向，你将会错过很多精彩的东西，因为他们只是对当前实际问题的抽象后形成的工具。正如[某人](https://en.wikipedia.org/wiki/Shunry%C5%AB_Suzuki#Quotations)所说，在初学者的脑袋中，是充满可能性的。而在专家的头脑中，可能就只习惯了那一种想法。

* 在本文中，我们将学习怎样从头开始使用函数式编程语言构建一个常用的解析器。他们具有很多的有点，一旦你掌握其中的基本思想，和基本原理，作为唯一的抽象，你将在基本组合器之上建立自己的抽象。所有这些必须建立在你使用他们之上。

## 怎样利用好这篇文章
* 强烈建议你新建一个新的Rust项目，并在阅读时，将代码片段键入到文件 `src/lib.rs` 中 （您可以直接从页面赋值代码片段，但最好手打，因为这样会确保你完整的阅读代码）。本文会按顺序介绍你需要的每一段代码。请注意，它可能会引入你之前编写的函数，这种情况下，你应该使用新版本的代码替换旧版本的。
* 代码是基于 `rustc 1.34.0` 版本的编译器的，它是2018大版本的。因此只要确保你使用的是2018（检查 `Cargo.toml` 是否包含了 `edition = "2018"` ）的大版本，你就能遵循使用更新的编译器。代码无需外部依赖。
* 如你所料，要运行文章中介绍的测试，可以使用 `cargo test`

## 折磨人的标记语言
* 我们将为简化版的 `XML` 编写一个解析器。它类似于这样：

```
<parent-element>
  <single-element attribute="value" />
</parent-element>
```

* `XML` 元素以符号 `<` 和一个标识符开始，标识符由若干字母、数字或 `-` 组成。其后是一些空格，或一些可选的属性列表：标识符后跟随一个 `=` 和双引号包含一些字符串。最后，可能有一个 `/>` 进行结束，表示没有子元素的单个元素，也可能有一个 `>` 表示后面有一些列子元素，最后一个结束标记以 `</` 开头，后面跟一个标识符，该标识符必须在与开始标识符标记匹配，最后是 `>` 。
* 这就是我们要做的。没有名称空间，没有文本节点，没有其他节点，而且绝对没有模式验证。我们甚至不需要为这些字符串支持转义符号——它们从第一个双引号开始，到下一个双引号结束，就是这样。如果你想要在实际的字符串中使用双引号，你可以将难处理的需求放到后面。
* 我们将把这些元素解析成类似于这样的结构：

```rust
#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String,
    attributes: Vec<(String, String)>,
    children: Vec<Element>,
}
```

* 没有泛型，只有一个带有名称的字符串（即每个标记开头的标识符）、一些字符串的属性（标识符和值），和一个看起来和父元素完全一样的子元素列表。
* （如果你正在键入代码，请确保包含这些 `derives` 。稍后你会需要用到的。）

## 定义解析器
* 那么，是时候开始编写解析器了。
* 解析是从数据流派生出结构的过程。解析器就是用来梳理结构的东西。
* 在我们将要探讨的规程中，解析器最简单的形式就是一个函数，它接收一些输入并返回已解析的输出和输入的其余部分，或者一个错误提示：“无法解析”。
* 简而言之，这也是解析器在更复杂的场景中也是这个样子。你可能会使输入、输出和错误复杂化，如果你要有好的错误信息，你需要它，但是解析器保持么不变：消费输入和将解析的结果和其他输入的剩余东西进行输出，或者提示出它无法将输入解析并输出。
* 我们把它标记为函数类型

```rust
Fn(Input) -> Result<(Input, Output), Error>
```

* 更详细的说，在我们的例子中，我们要填充类型，就会得到类似下面的结果，因为我们要做的是将一个字符串转换成一个元素结构，这一点上，我们不想将错误复杂的显示出来，所以我们只将我们无法解析的错误作为字符串返回：

```rust
Fn(&str) -> Result<(&str, Element), &str>
```

* 我们使用字符串 slice ，因为它是指向一个字符串片段的有效指针，我们可以通过 slice 的方式引用它，无论怎么做，消费输入的字符串 slice ，并返回剩余的部分和结果。
* 使用 `&[u8]` （一个字节的 slice ，假设我们限制自己使用 ASCII 对应的字符） 作为输入的类型可能会更简洁，特别是因为一个字符串 slice 的行为不同于其他类型的 slice ，尤其是在不能用数字索引对字符串进行索引的情况下，你必须像这样使用一个 slice `input[0..1]` 。另一方面，对于解析字符串它们提供许多方法，而字符数组 slice 没有。
* 实际上，大多数情况下，我们将依赖这些方法，而不是对其进行索引，因为， `Unicode` 。在 utf-8 中，所有rust字符串都是 utf-8 的，这些索引并不总是对应于单个字符，最好让标准库帮我们处理这个问题。

## 第一个解析器
* 让我们尝试编写一个解析器，它只查看字符串中的第一个字符，并判断它是否是字母 `a`。

```rust
fn the_letter_a(input: &str) -> Result<(&str, ()), &str> {
  match input.chars().next() {
      Some('a') => Ok((&input['a'.len_utf8()..], ())),
      _ => Err(input),
  }
}
```

* 首先，我们看下输入和输出的类型：我们将一个字符串 slice 作为输入，正如我们讨论的，我们返回一个包含 `(&str, ())` 的      `Result` 或者错误类型 `&str` 。有趣的是 `(&str, ())` 这部分：正如我们所讨论的，我们应该返回一个能够分析下一个输入的结果的元组。 `&str` 是下一个输入，并且结果是单独的类型 `()` ，因为如果这个解析器成功运行，它将只能得到一个结果（只找到了字母 `a` ），并且在这种情况下，我们不特别需要返回字面 `a` ，我们只需要指出成功的找到了它就行。

* 因此，我们看看解析器本身的代码。首先获取输入的第一个字符：`input.chars().next()` 。我们并没有尝试性的依赖标准库来避免带来 `Unicode` 的问题——我们要求它为字符串的字符提供 一个 `chars()` 迭代器，然后从其中取出第一个字符。这就是一个 `char` 类型的项，并且通过 `Option` 包装着，即 `Option<char>` ，如果是 `None` 类型的 `Option` 则意味着我们获取到的是一个空字符串。

* 更糟糕的是，获取到的字符甚至可能不是我们想象中的 `Unicode` 字符。这很可能就是 `Unicode` 中的 "[grapheme cluster](http://www.unicode.org/glossary/#grapheme_cluster)" ，它可以由几个字符组成，这些字符实际上表示 "[scalar values](http://www.unicode.org/glossary/#unicode_scalar_value)" ，它比 "grapheme cluster" 大约还低2个层次。但是，这种方法未免也太激进了，就我们的目的而言，我们甚至不太可能看到 `ASCII` 字符集以外的字符，所以就先这么着吧。

* 我们匹配一下 `Some('a')`，这就是我们正在寻找的特定结果，如果匹配成功，我们将返回成功 `Ok((&input['a'.len_utf8]()..], ()))` 。也就是说，我们从字符串 slice 中移出的解析的项（ 'a' ），并返回其余的字符，以及解析后的值，也就是 `empty()` 。考虑到 `Unicode` 字符集，在对字符串 `slice` 前，我们用标准库中的方法查询一下字符 `a` 在 UTF-8 中的长度——长度是1，但绝不要去猜测 Unicode 字符。

* 如果我们得到其他 `Some(char)` ，或者没有，我们将返回一个 error 。正如之前提到的，我们现在的错误类型就是解析失败时的字符串 `slice` ，也就是我们我们传入的输入。它不是以 `a` 开头，所以返回错误给我们。这不是一个很严重的错误，但至少比“一些地方出了致命错误”要好一些。

* 实际上，我们不需要这个解析器解析这个 `XML` ，但是我们需要做的第一件事是寻找开始的 `<` ，所以我们需要一些类似的东西。我们还需要解析 `>` ,`/` 和 `=` ，所以，也许我们可以创建一个函数来构建一个解析器来解析我们想要解析的字符。

## 解析器构建器
* 我们想象一下，如果要写一个函数：它可以为任意长度的静态字符串（不仅仅是单个字符）生成一个解析器。这样做甚至更简单一些，因为字符串 slice 是一个合法的 UTF-8 字符串 slice ，并且暂且不考虑 Unicode 字符集问题。

```rust
fn match_literal(expected: &'static str)
    -> impl Fn(&str) -> Result<(&str, ()), &str>
{
    move |input| match input.get(0..expected.len()) {
        Some(next) if next == expected => {
            Ok((&input[expected.len()..], ()))
        }
        _ => Err(input),
    }
}
```

* 现在看起来有点不一样了。
* 首先，看看类型，。我们的函数看起来不像一个解析器，它现在接受我们期望的字符串作为参数，并且返回值是看起来像解析器一样的东西。它是一个返回值是函数的函数——换句话说，它是一个高阶函数。基本上，我们在写的是生成一个像之前我们的 `the_letter_a` 一样的函数。

* 因此，我们不是在函数体中执行一些逻辑，而是返回一个闭包，这个闭包才是执行逻辑的地方，并且与之前的解析器的“函数签名”是匹配的。
* 匹配模式是一样的，只是我们不能直接匹配字符串文本，因为我们不知道他具体是什么，所以我们使用 `match` 和条件判断 `if next == expected` 来匹配。因此，它和之前完全一样，只是逻辑的执行是在闭包的内部。

## 测试解析器
* 我们将编写一个测试来确保我们做的是对的。

```rust
#[test]
fn literal_parser() {
    let parse_joe = match_literal("Hello Joe!");
    assert_eq!(
        Ok(("", ())),
        parse_joe("Hello Joe!")
    );
    assert_eq!(
        Ok((" Hello Robert!", ())),
        parse_joe("Hello Joe! Hello Robert!")
    );
    assert_eq!(
        Err("Hello Mike!"),
        parse_joe("Hello Mike!")
    );
}
```

* 首先，我们构建解析器： `match_literal("Hello Joe!")` 。这应该使用字符串 `Hello Joe!` 作为参数，并返回字符串的其余部分，否则它应该提示失败并返回整个字符串。
* 在第一种情况下，我们只是向他提供它期望的字符串作为参数，然后，我们看到它返回一个空字符串和 `()` 的值，这意味着：“我们按照正常流程解析了字符串，实际上你并不需要它返回给你这个值”。

* 在第二种情况下，我们给它输入字符串 `Hello Joe! Hello Robert!` ，并且我们确实看到它使用了字符串 `Hello Joe!` 并返回其余的输入：` Hello Robert!`(空格开头的所有字符串)
* 在第3个例子中，我们输入了一些不正确的值： `Hello Mike!`，请注意，它确实根据输入给出了错误并中断执行。一般来说， `Mike` 并不是正确的输入部分，它不是这个解析器要寻找的对象。

## 用于不固定参数的解析器
* 这样，我们来解析 `<`,`>`,`=`甚至 `</` 和 `/>` 。我们实际上做的差不多了。
* 在开始 `<` 后的下一个元素是元素的名称。虽然我们不能用一个简单的字符串比较来做到这一点，但是我们可以用正则表达式。
* 但是我们要克制自己，它将是一个很容易在简单代码中复制的正则表达式，并且我们不需要为此而去依赖于 `regex` 的 crate 库。我们要试试只试用 Rust 标准库来进行编写自己的解析器。

* 回顾元素名称标识符的规范，它大概是这样：一个字母的字符，然后是若干个字母数字中横线 `-` 等多个字符。

```rust
fn identifier(input: &str) -> Result<(&str, String), &str> {
    let mut matched = String::new();
    let mut chars = input.chars();

    match chars.next() {
        Some(next) if next.is_alphabetic() => matched.push(next),
        _ => return Err(input),
    }

    while let Some(next) = chars.next() {
        if next.is_alphanumeric() || next == '-' {
            matched.push(next);
        } else {
            break;
        }
    }

    let next_index = matched.len();
    Ok((&input[next_index..], matched))
}
```

* 和往常一样，我们先查看一些类型。这次，我们不是编写函数来构建解析器，而是像最开始的那样编写解析器本身。这里值得注意的是，我们没有返回 `()` 的 result 类型，而是返回一个 String 元组，以及剩余的输入部分。这个字符串将包含我们刚刚解析过的标识符。
* 记住这一点，首先我们创建一个空字符串，并调用它进行匹配。这将得到我们的结果值。我们还会得到一个迭代器来逐个遍历这些分开的输入字符。








* 翻译进度： `...just need to indicate that we succeeded in finding i...`

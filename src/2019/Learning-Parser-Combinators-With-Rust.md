# 使用Rust进行解析器学习
* 这是一篇翻译文：*原文链接 https://bodil.lol/parser-combinators*
* 翻译首发地址：https://github.com/suhanyujie/article-transfer-rs/blob/master/src/2019/Learning-Parser-Combinators-With-Rust.md
>正文开始：


* 本文面向会使用Rust编程的人员，提供一些解析器的基础知识。如果没有其他基础，将会解释和Rust无关的一些内容，并且，使用Rust实现这个会更加超出预期。如果你还不了解Rust，这个文章也不会讲如何使用Rust；如果你已经了解Rust，那它也不能打包票能教会您解析器知识。如果你想学习Rust，我推荐阅读[《The Rust Programming Language》](https://doc.rust-lang.org/book/)。

## 初学者的独白
* 在很多程序员的职业生涯中，可能都会有这样一个时刻，发现自己需要一个解析器。
* 小白程序员可能会问：解析器是什么？
* 中级程序员会问：这很简单，我会写正则表达式。
* 高级程序员会说：闪开，我知道 `lex` 和 `yacc` 。
* 只有小白的态度是端正的。
* 并不说正则不好。（但请不要尝试将一个复杂的解析器写成正则表达式。）也不是说使用像 `lexer` 生成器这种强大的工具就没有显得技术含量，这些工具经过长久的迭代和改进，已经达到了很好的程度。但从0开始学解析器是很有趣的。而如果你直接走正则表达式或解析器生成器的方向，你将会错过很多精彩的东西，因为他们只是对当前实际问题的抽象后形成的工具。正如[某人](https://en.wikipedia.org/wiki/Shunry%C5%AB_Suzuki#Quotations)所说，在初学者的脑袋中，是充满可能性的。而在专家的头脑中，可能就只习惯了那一种想法。

* 在本文中，我们将学习怎样从头开始使用函数式编程语言构建一个常用的解析器。他们具有很多的有点，一旦你掌握其中的基本思想，和基本原理，作为唯一的抽象，你将在基本组合器之上建立自己的抽象。所有这些必须建立在你使用他们之上。

## 怎样利用好这篇文章
* 强烈建议你新建一个新的Rust项目，并在阅读时，将代码片段键入到文件 `src/lib.rs` 中 （您可以直接从页面赋值代码片段，但最好手打，因为这样会确保你完整的阅读代码）。本文会按顺序介绍你需要的每一段代码。请注意，它可能会引入你之前编写的函数，这种情况下，你应该使用新版本的代码替换旧版本的。
* 代码是基于 `rustc 1.34.0` 版本的编译器的，它是2018大版本的。因此只要确保你使用的是2018（检查 `Cargo.toml` 是否包含了 `edition = "2018"` ）的大版本，你就能遵循使用更新的编译器。代码无需外部依赖。
* 如你所料，要运行文章中介绍的测试，可以使用 `cargo test`

## 折磨人的标记语言
* 我们将为简化版的 `XML` 编写一个解析器。它类似于这样：

```
<parent-element>
  <single-element attribute="value" />
</parent-element>
```

* `XML` 元素以符号 `<` 和一个标识符开始，标识符由若干字母、数字或 `-` 组成。其后是一些空格，或一些可选的属性列表：标识符后跟随一个 `=` 和双引号包含一些字符串。最后，可能有一个 `/>` 进行结束，表示没有子元素的单个元素，也可能有一个 `>` 表示后面有一些列子元素，最后一个结束标记以 `</` 开头，后面跟一个标识符，该标识符必须在与开始标识符标记匹配，最后是 `>` 。
* 这就是我们要做的。没有名称空间，没有文本节点，没有其他节点，而且绝对没有模式验证。我们甚至不需要为这些字符串支持转义符号——它们从第一个双引号开始，到下一个双引号结束，就是这样。如果你想要在实际的字符串中使用双引号，你可以将难处理的需求放到后面。
* 我们将把这些元素解析成类似于这样的结构：

```rust
#[derive(Clone, Debug, PartialEq, Eq)]
struct Element {
    name: String,
    attributes: Vec<(String, String)>,
    children: Vec<Element>,
}
```

* 没有泛型，只有一个带有名称的字符串（即每个标记开头的标识符）、一些字符串的属性（标识符和值），和一个看起来和父元素完全一样的子元素列表。
* （如果你正在键入代码，请确保包含这些 `derives` 。稍后你会需要用到的。）

## 定义解析器
* 那么，是时候开始编写解析器了。
* 解析是从数据流派生出结构的过程。解析器就是用来梳理结构的东西。
* 在我们将要探讨的规程中，解析器最简单的形式就是一个函数，它接收一些输入并返回已解析的输出和输入的其余部分，或者一个错误提示：“无法解析”。
* 简而言之，这也是解析器在更复杂的场景中也是这个样子。你可能会使输入、输出和错误复杂化，如果你要有好的错误信息，你需要它，但是解析器保持么不变：消费输入和将解析的结果和其他输入的剩余东西进行输出，或者提示出它无法将输入解析并输出。
* 我们把它标记为函数类型

```rust
Fn(Input) -> Result<(Input, Output), Error>
```

* 更详细的说，在我们的例子中，我们要填充类型，就会得到类似下面的结果，因为我们要做的是将一个字符串转换成一个元素结构，这一点上，我们不想将错误复杂的显示出来，所以我们只将我们无法解析的错误作为字符串返回：

```rust
Fn(&str) -> Result<(&str, Element), &str>
```

* 我们使用字符串 slice ，因为它是指向一个字符串片段的有效指针，我们可以通过 slice 的方式引用它，无论怎么做，消费输入的字符串 slice ，并返回剩余的部分和结果。
* 使用 `&[u8]` （一个字节的 slice ，假设我们限制自己使用 ASCII 对应的字符） 作为输入的类型可能会更简洁，特别是因为一个字符串 slice 的行为不同于其他类型的 slice ，尤其是在不能用数字索引对字符串进行索引的情况下，你必须像这样使用一个 slice `input[0..1]` 。另一方面，对于解析字符串它们提供许多方法，而字符数组 slice 没有。
* 实际上，大多数情况下，我们将依赖这些方法，而不是对其进行索引，因为， `Unicode` 。在 utf-8 中，所有rust字符串都是 utf-8 的，这些索引并不总是对应于单个字符，最好让标准库帮我们处理这个问题。

## 第一个解析器
* 让我们尝试编写一个解析器，它只查看字符串中的第一个字符，并判断它是否是字母 `a`。

```rust
fn the_letter_a(input: &str) -> Result<(&str, ()), &str> {
  match input.chars().next() {
      Some('a') => Ok((&input['a'.len_utf8()..], ())),
      _ => Err(input),
  }
}
```

* 首先，我们看下输入和输出的类型：我们将一个字符串 slice 作为输入，正如我们讨论的，我们返回一个包含 `(&str, ())` 的      `Result` 或者错误类型 `&str` 。有趣的是 `(&str, ())` 这部分：正如我们所讨论的，我们应该返回一个能够分析下一个输入的结果的元组。 `&str` 是下一个输入，并且结果是单独的类型 `()` ，因为如果这个解析器成功运行，它将只能得到一个结果（只找到了字母 `a` ），并且在这种情况下，我们不特别需要返回字面 `a` ，我们只需要指出成功的找到了它就行。

* 翻译进度： `...just need to indicate that we succeeded in finding i...`
